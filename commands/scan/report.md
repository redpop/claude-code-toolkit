---
allowed-tools: Task, Read, Grep, Bash(jq:*), Bash(sort:*), Bash(awk:*), Bash(find:*), Bash(ls:*), Write
description: Intelligent analysis of code quality reports with trend detection, prioritization, and actionable insights
argument-hint: [report.json] [--latest] [--compare=other-report.json] [--history] [--trends] [--quick-wins] [--export-md] [--generate-action-plan]
---

**IMPORTANT: This command analyzes existing report files. File creation is ONLY allowed for analysis exports when --export flags are used.**

# Report Analysis Command

This command provides intelligent analysis of code quality reports generated by analysis commands like `/analyze-deep`, `/security-audit`, etc. It identifies trends, prioritizes issues, generates actionable insights, and can create executable action plans with specific fix commands.

**NEW**: With `--generate-action-plan`, this command creates a structured todo list with exact commands to fix identified issues, enabling seamless workflow automation with `/workflow:execute-action-plan`.

## Usage Modes

### 1. Single Report Analysis

```bash
/analyze-report report.json                    # Basic analysis
/analyze-report --latest                       # Analyze most recent report (NEW)
/analyze-report report.json --quick-wins      # Focus on easy fixes
/analyze-report report.json --export-md       # Export analysis
```

### 2. Report Comparison

```bash
/analyze-report current.json --compare=previous.json
/analyze-report --latest --compare=previous.json      # Compare latest with previous
/analyze-report report1.json --compare=report2.json --export-md=comparison.md
```

### 3. Historical Trend Analysis

```bash
/analyze-report reports/*.json --trends        # Analyze all reports
/analyze-report --history                      # Use .report-history.json
/analyze-report --history --last=10           # Last 10 reports only
```

### 4. Multi-Project Analysis

```bash
/analyze-report frontend/report.json backend/report.json mobile/report.json
/analyze-report */latest-report.json --export-md=cross-project-analysis.md
```

### 5. Action Plan Generation

```bash
/analyze-report report.json --generate-action-plan                    # Generate executable action plan
/analyze-report --latest --generate-action-plan                       # From latest report (NEW)
/analyze-report report.json --generate-action-plan --team-mode       # Split tasks for team
/analyze-report report.json --generate-action-plan --sprint=2-weeks  # Sprint-sized chunks
```

### 6. Using --latest Flag (NEW)

The `--latest` flag automatically finds the most recent report file:

```bash
/analyze-report --latest                              # Analyze latest report
/analyze-report --latest --quick-wins                # Quick wins from latest
/analyze-report --latest --generate-action-plan      # Action plan from latest
/analyze-report --latest --export-md                 # Export analysis of latest
```

## Analysis Workflow

### Phase 1: Report Loading and Validation

1. **Handle --latest Flag**:

   - If `--latest` is specified:
     - Search for most recent report: `ls -t *analysis*.json *report*.json *scan*.json 2>/dev/null | head -1`
     - Alternative approach: `find . -maxdepth 1 -name "*analysis*.json" -o -name "*report*.json" -o -name "*scan*.json" | head -1`
     - Use timestamps in filenames or file modification times
     - Support common patterns: `analysis-YYYYMMDD-HHMMSS.json`, `deep-scan-*.json`, etc.

2. **Load Report(s)**:

   - Parse JSON report file(s)
   - Validate schema compliance
   - Extract metadata and metrics
   - Check report completeness

3. **Normalize Data**:
   - Handle different report versions
   - Standardize metric scales
   - Align severity classifications
   - Process timestamps

### Phase 2: Deep Analysis

Use Task tool with subagent_type="report-analyzer":
"Analyze the following report data:

- Mode: [single/compare/trends/history]
- Focus: [general/quick-wins/critical/trends]
- Reports: [list of reports with metadata]

**IMPORTANT: When --generate-action-plan is used, map each issue to its corresponding fix command:**

Issue Type → Command Mapping:

- 'O(n²) Algorithm' → `/prefix:fix:performance --target=algorithm --file={file}`
- 'Code Duplication' → `/prefix:fix:duplicates --file={file} --extract-shared`
- 'Missing Tests' → `/prefix:generate:tests --focus={module} --coverage-target=90`
- 'God Component' → `/prefix:refactoring-expert 'Break down {file} into smaller components'`
- 'Security Issue' → `/prefix:fix:security --target={vulnerability_type} --file={file}`
- 'Documentation Gap' → `/prefix:fix:documentation --add-jsdoc --file={file}`

Provide:

1. Executive summary with key insights
2. Prioritized action items with ROI scores and **specific commands**
3. Trend analysis (if multiple reports)
4. Executable action plan with command mapping"

### Phase 3: Generate Insights

The analyzer will provide:

1. **Health Score Analysis**:

   - Current state assessment
   - Comparison with previous/target
   - Component breakdown
   - Improvement potential

2. **Issue Prioritization**:

   - ROI-based ranking
   - Quick wins identification
   - Dependency analysis
   - Resource optimization

3. **Trend Detection**:

   - Improvement velocity
   - Regression alerts
   - Predictive projections
   - Anomaly detection

4. **Actionable Recommendations**:
   - Immediate actions
   - Sprint planning
   - Long-term strategy
   - Team allocation

### Phase 4: Export Results (if requested)

Generate formatted output:

```markdown
# Code Quality Analysis Report

**Generated**: {timestamp}
**Reports Analyzed**: {count}
**Analysis Type**: {single/comparison/trend}

## Executive Summary

{key_insights}

## Priority Actions

### 🔥 Immediate (Best ROI)

{high_roi_items}

### ⚡ Quick Wins (< 4 hours)

{quick_win_items}

## Trend Analysis

{trend_charts_and_insights}

## Detailed Findings

{categorized_analysis}
```

### Phase 5: Action Plan Generation (if --generate-action-plan)

When the `--generate-action-plan` flag is used, create an executable action plan as a Markdown file with **specific fix commands** mapped to each issue type:

**Issue-to-Command Mapping:**

```javascript
const ISSUE_COMMAND_MAPPING = {
  // Performance Issues
  "O(n²) Algorithm": "/prefix:fix:performance --target=algorithm --file={file}",
  "Memory Leak": "/prefix:fix:performance --target=memory --file={file}",
  "Database N+1":
    "/prefix:fix:performance --target=database --batch-operations",

  // Code Quality Issues
  "Code Duplication": "/prefix:fix:duplicates --file={file} --extract-shared",
  "God Component":
    "/prefix:refactoring-expert 'Break down {file} into smaller components'",
  "Long Parameter List":
    "/prefix:fix:quick-wins --target=parameters --file={file}",

  // Testing Issues
  "Missing Tests":
    "/prefix:generate:tests --focus={module} --coverage-target=90",
  "Low Coverage": "/prefix:generate:tests --file={file} --increase-coverage",

  // Security Issues
  "XSS Vulnerability": "/prefix:fix:security --target=xss --file={file}",
  "Input Validation": "/prefix:fix:security --target=validation --file={file}",

  // Architecture Issues
  "Tight Coupling": "/prefix:code-architect 'Reduce coupling in {file}'",
  "Layer Violation":
    "/prefix:code-architect 'Fix architecture violations in {file}'",

  // Documentation Issues
  "Missing JSDoc": "/prefix:fix:documentation --add-jsdoc --file={file}",
  "Outdated Comments":
    "/prefix:fix:documentation --update-comments --file={file}",
};
```

````markdown
# Action Plan Report

**Generated**: {timestamp}
**Based on**: {report_filename}
**Total Estimated Effort**: {total_hours}h
**Team Size Recommendation**: {team_size}

## Todo List (Prioritized by ROI)

### 🔴 Critical Security ({total_hours}h)

- [ ] **Input Sanitization** (3h)
  - Command: `/global:fix:security --focus="xss,sanitization" --auto-fix`
  - Files: src/components/_, src/utils/_
  - Impact: Prevents XSS attacks
- [ ] **JSON Validation** (2h)
  - Command: `/global:fix:security --focus="validation" --library="zod"`
  - Files: src/services/dataImport.ts
  - Impact: Prevents prototype pollution

### 🟡 Quick Wins ({total_hours}h)

- [ ] **Remove Code Duplication** (2h)

  - Command: `/global:fix:duplicates --file="src/utils/pdfExport.ts"`
  - Lines saved: 140
  - Impact: 50% maintenance reduction

- [ ] **Batch DB Operations** (4h)
  - Command: `/global:orchestration:performance-scan --auto-fix --focus="database"`
  - Expected improvement: 70% faster imports

### 🟢 Enhancement ({total_hours}h)

- [ ] **Increase Test Coverage** (8h)
  - Command: `/global:generate:tests --coverage-target=60 --focus="critical"`
  - Current: 30% → Target: 60%

### 📊 Progress Tracking

- [ ] **Create Baseline**
  - Command: `/global:security:baseline --save`
  - Run before starting fixes
- [ ] **Weekly Review**
  - Command: `/global:analysis:analyze-deep --compare-baseline`
  - Track improvement metrics

## Execution Instructions

1. **Start with security baseline**:
   ```bash
   /global:security:baseline --save
   ```
````

2. **Execute tasks by priority**:

   - Complete all 🔴 Critical items first
   - Then proceed to 🟡 Quick Wins
   - Finally work on 🟢 Enhancements

3. **After completion, run**:
   ```bash
   /global:workflow:completion-report --action-plan=action-plan-{timestamp}.md
   ```

## Team Allocation (if --team-mode)

### Senior Developer (40h/week)

- [ ] Input Sanitization (3h)
- [ ] JSON Validation (2h)
- [ ] Architecture Review (8h)

### Mid-level Developer (40h/week)

- [ ] Batch DB Operations (4h)
- [ ] Test Coverage (8h)
- [ ] Performance Fixes (8h)

### Junior Developer (40h/week)

- [ ] Remove Console Logs (1h)
- [ ] Code Duplication (2h)
- [ ] Documentation (8h)

````

**IMPORTANT: When --generate-action-plan is used, ALWAYS create the action plan as a Markdown file:**

1. **Generate filename**: `ACTION-PLAN-{YYYYMMDD-HHMMSS}.md`
2. **Write to file**: Use Write tool to create the action plan file in current directory
3. **Include checkboxes**: Use `- [ ]` for uncompleted tasks, `- [x]` for completed
4. **Reference report**: Include source report filename in header

**KI-Optimized Action Plan Template:**
```markdown
# ACTION-PLAN-{YYYYMMDD-HHMMSS}

SOURCE: {report_filename}
PRIORITY: ROI_DESCENDING

## TASKS

- [ ] /prefix:fix:performance --target=algorithm --file=src/utils/loanCalculations.ts
  REASON: O(n²) algorithm causing 87% performance degradation
  ROI: 10.0

- [ ] /prefix:fix:performance --target=react-renders --file=src/components/LoanCalculator.tsx
  REASON: Excessive re-renders (8-12 per keystroke)
  ROI: 9.0

- [ ] /prefix:fix:architecture --target=layer-violations --file=src/utils/dataExportImport.ts
  REASON: Direct database access bypassing abstractions
  ROI: 8.0

- [ ] /prefix:gen:tests --focus=storage --coverage-target=90
  REASON: Storage layer at 20% coverage, critical paths at 35%
  ROI: 8.0

- [ ] /prefix:fix:duplicates --file=src/utils/pdfExport.ts --extract-shared
  REASON: 180+ duplicate lines in PDF export
  ROI: 7.5

[Additional tasks in ROI order...]

## EXECUTION

To execute all tasks:
/prefix:auto:execute --latest

To execute specific ROI threshold:
/prefix:auto:execute --latest --min-roi=8.0

To validate after execution:
/prefix:scan:quality . --compare={original_report}
````

The action plan includes:

- Exact commands to run for each fix
- Time estimates based on complexity
- Clear prioritization by ROI
- Progress tracking with checkboxes
- Team allocation suggestions (if requested)

### Simplified Output Format

When generating reports, use this streamlined format:

````markdown
# ✅ Action Plan Generated

📄 **Saved to**: ACTION-PLAN-{timestamp}.md  
📊 **Tasks**: {total_count} prioritized fixes  
🎯 **Top ROI**: {highest_roi_task}

## 🚀 Your Next Step

```bash
/prefix:auto:execute --latest
```
````

**Why?** This will automatically execute all fixes in priority order.

---

<details>
<summary>📋 Plan Summary (click to expand)</summary>

- Critical fixes: {critical_count}
- Quick wins: {quick_wins_count}
- Total improvement: Health score {current} → {target}

Top 3 Actions:

1. {top_action_1} (ROI: {roi_1})
2. {top_action_2} (ROI: {roi_2})
3. {top_action_3} (ROI: {roi_3})

</details>

💡 **Tip**: Start execution now - all tasks are automated and safe to run.

```

## Advanced Features

### ROI Scoring
```

ROI = (Impact × 10) / Effort_Hours
Impact = Severity × Scope × Business_Value

````

### Quick Win Detection
Identifies issues that:
- Take < 4 hours to fix
- Have medium+ impact
- No complex dependencies
- Clear implementation path

### Anomaly Detection
Flags unusual patterns:
- Sudden metric drops
- Outlier findings
- Regression indicators
- Unexpected improvements

### Velocity Calculation
Tracks improvement speed:
- Issues fixed/week
- Quality score delta/sprint
- Coverage improvement rate
- Time to target estimation

## Command Examples

### Basic Analysis
```bash
# Analyze latest report
/analyze-report analyze-deep-20250128.json

# Focus on quick wins
/analyze-report report.json --quick-wins

# Export analysis
/analyze-report report.json --export-md=analysis.md
````

### Comparison

```bash
# Compare two reports
/analyze-report new.json --compare=old.json

# Compare with percentage changes
/analyze-report current.json --compare=baseline.json --show-deltas
```

### Trend Analysis

```bash
# Analyze all reports in directory
/analyze-report reports/*.json --trends

# Use historical data
/analyze-report --history --trends

# Last 30 days only
/analyze-report --history --days=30 --trends
```

### Team Planning

```bash
# Generate sprint planning data
/analyze-report report.json --sprint-planning

# Estimate fix timeline
/analyze-report report.json --estimate-timeline

# Team allocation suggestions
/analyze-report report.json --team-allocation
```

### Action Plan Generation

```bash
# Generate executable action plan
/analyze-report report.json --generate-action-plan

# Action plan with team allocation
/analyze-report report.json --generate-action-plan --team-mode

# Sprint-sized action plan
/analyze-report report.json --generate-action-plan --sprint=2-weeks

# Action plan focusing on security
/analyze-report report.json --generate-action-plan --focus=security

# Export action plan
/analyze-report report.json --generate-action-plan --export-md=action-plan.md
```

## Integration Examples

### CI/CD Pipeline

```yaml
- name: Analyze Code Quality
  run: |
    /analyze-deep --export-json=report.json
    /analyze-report report.json --quick-wins --export-md=quick-wins.md

    # Fail if quality degraded
    /analyze-report report.json --compare=baseline.json --fail-on-regression
```

### Daily Standup Report

```bash
#!/bin/bash
# Generate daily progress report
/analyze-report --history --last=2 --export-md=daily-progress.md
echo "Progress: $(jq '.improvement_percentage' daily-progress.json)%"
```

### Sprint Planning

```bash
# Generate sprint backlog from quick wins
/analyze-report latest-report.json --quick-wins --export-json=backlog.json

# Create tickets
jq '.quick_wins[]' backlog.json | while read -r issue; do
  create-jira-ticket "$issue"
done
```

## Output Interpretation

### Health Score Trends

- **Improving (📈)**: Positive delta > 5%
- **Stable (➡️)**: Delta between -5% and +5%
- **Declining (📉)**: Negative delta > 5%

### Priority Levels

- **🔥 Critical**: Fix immediately (ROI > 8)
- **⚡ High**: Next sprint (ROI 5-8)
- **⚠️ Medium**: Plan for quarter (ROI 2-5)
- **💡 Low**: Consider if time permits (ROI < 2)

### Effort Estimates

- **Minutes**: < 1 hour
- **Hours**: 1-8 hours
- **Days**: 1-5 days
- **Weeks**: > 5 days

This command transforms raw analysis data into actionable intelligence, helping teams make data-driven decisions about code quality improvements.
